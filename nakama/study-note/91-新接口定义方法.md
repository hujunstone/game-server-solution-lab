在 Nakama 中，添加“游戏过程中的接口”（例如：领取每日奖励、上传战斗结算数据、购买物品）的标准方式是使用 **RPC (Remote Procedure Call)**。

服务端定义一个 RPC 函数，客户端通过 SDK 调用该函数的 ID。

---

### 第一部分：服务端开发 (Go)

我们将实现一个 **“领取每日奖励”** 的功能：玩家调用接口，服务端检查上次领取时间，如果超过24小时，则发放金币。

#### 1. 工程目录结构
建议将游戏逻辑代码与登录逻辑分开，建立 `gameplay` 目录。

```text
nakama-server/
├── go.mod
├── main.go                 # 注册 RPC
├── login/                  # (之前的登录逻辑)
└── gameplay/               # (新增) 游戏核心逻辑
    └── daily_reward.go     # 每日奖励的具体实现
```

#### 2. 代码实现

**A. `main.go` (注册 RPC)**
在 `InitModule` 中注册新的接口 ID。

```go
package main

import (
	"context"
	"database/sql"
	"nakama-server/gameplay" // 引入新包
	"nakama-server/login"
	"github.com/heroiclabs/nakama-common/runtime"
)

func InitModule(ctx context.Context, logger runtime.Logger, db *sql.DB, nk runtime.NakamaModule, initializer runtime.Initializer) error {
	// ... 之前的登录 Hook ...
	if err := login.RegisterLoginHooks(initializer); err != nil { return err }

	// === 新增：注册游戏逻辑 RPC ===
	// 接口ID: "claim_daily_reward"
	if err := initializer.RegisterRpc("claim_daily_reward", gameplay.RpcClaimDailyReward); err != nil {
		return err
	}

	return nil
}
```

**B. `gameplay/daily_reward.go` (业务逻辑)**

```go
package gameplay

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/heroiclabs/nakama-common/runtime"
)

// 定义返回给客户端的结构
type DailyRewardResponse struct {
	Success     bool   `json:"success"`
	Message     string `json:"message"`
	GoldReceived int64  `json:"gold_received"`
	NewBalance  int64  `json:"new_balance"`
}

// RpcClaimDailyReward: 领取奖励接口
func RpcClaimDailyReward(ctx context.Context, logger runtime.Logger, db *sql.DB, nk runtime.NakamaModule, payload string) (string, error) {
	// 1. 获取当前调用接口的用户 ID
	userID, ok := ctx.Value(runtime.RUNTIME_CTX_USER_ID).(string)
	if !ok {
		return "", runtime.NewError("未登录用户无法调用", 13)
	}

	// 2. 检查 Storage 中上次领取的时间
	// Collection: "rewards", Key: "daily_last_claim"
	objects, err := nk.StorageRead(ctx, []*runtime.StorageRead{
		{
			Collection: "rewards",
			Key:        "daily_last_claim",
			UserID:     userID,
		},
	})
	if err != nil {
		return "", runtime.NewError("存储读取失败", 13)
	}

	// 3. 判断时间逻辑
	now := time.Now().Unix()
	canClaim := true
	
	if len(objects) > 0 {
		var data map[string]int64
		if err := json.Unmarshal([]byte(objects[0].Value), &data); err == nil {
			lastClaim := data["timestamp"]
			// 简单的逻辑：必须间隔 86400 秒 (24小时)
			if now - lastClaim < 86400 {
				canClaim = false
			}
		}
	}

	if !canClaim {
		// 返回 JSON 告诉客户端不能领取
		resp, _ := json.Marshal(DailyRewardResponse{
			Success: false, 
			Message: "冷却时间未到，请稍后再试",
		})
		return string(resp), nil
	}

	// 4. 发放奖励 (更新钱包)
	rewardAmount := int64(100)
	changes := map[string]int64{"gold": rewardAmount}
	metadata := map[string]interface{}{"source": "daily_reward"}
	
	// 更新钱包并获取最新余额
	_, _, err = nk.WalletUpdate(ctx, userID, changes, metadata, true)
	if err != nil {
		return "", runtime.NewError("发放奖励失败", 13)
	}

	// 5. 记录领取时间到 Storage
	newStorageData, _ := json.Marshal(map[string]int64{"timestamp": now})
	_, err = nk.StorageWrite(ctx, []*runtime.StorageWrite{
		{
			Collection: "rewards",
			Key:        "daily_last_claim",
			UserID:     userID,
			Value:      string(newStorageData),
			PermissionRead: 1, // 允许客户端读取(方便客户端显示倒计时)
			PermissionWrite: 0, // 禁止客户端写入(防止作弊)
		},
	})

	// 6. 返回成功信息
	resp, _ := json.Marshal(DailyRewardResponse{
		Success: true, 
		Message: "领取成功", 
		GoldReceived: rewardAmount,
	})
	return string(resp), nil
}
```

---

### 第二部分：客户端调用 (UE 蓝图)

在虚幻引擎中，Nakama 插件提供了 `RPC` 节点来调用服务端的逻辑。

假设你已经初始化了 Nakama Client 和 Session（在登录步骤完成）。

#### 蓝图步骤：

1.  **获取 Client 引用**：找到你保存的 Nakama Client 对象变量。
2.  **创建 RPC 请求**：
    *   在蓝图中搜索节点：**`Send RPC`** (或者叫 `RPC Async`)。
    *   **Context** (输入)：需要传入 User Session 对象（登录成功后获得的）。
    *   **Function ID** (输入)：填入我们在 Go 代码中注册的字符串 `"claim_daily_reward"`。
    *   **Payload** (输入)：服务端需要 JSON 字符串。如果接口不需要参数，填入空 JSON `"{}"`。
3.  **处理回调 (Event Delegates)**：
    *   Nakama 的蓝图操作通常是异步的，会有 `On Success` 和 `On Error` 两个执行引脚或事件绑定。

#### 详细蓝图逻辑描述：

*   **节点**: `Nakama Client -> Send RPC`
*   **输入引脚**:
    *   `Function Id`: `Make Literal String` -> Value: `"claim_daily_reward"`
    *   `Payload`: `Make Literal String` -> Value: `"{}"` (如果需要传参数，这里要构建 JSON 字符串)
*   **成功回调 (Success)**:
    *   输出参数通常有一个 `Payload (String)`。这是服务端返回的 JSON。
    *   你需要解析这个 JSON (例如使用 `VaRest` 插件或 UE 自带的 Json Utilities)。
    *   逻辑：解析 JSON -> 检查 `success` 字段 -> 如果为 true，弹出“获得100金币”提示；如果为 false，弹出 `message` 中的错误提示。
*   **失败回调 (Error)**:
    *   这是网络层面的错误（如服务器断开、RPC ID 不存在）。

---

### 第三部分：如何只在服务器测试 (curl)

在客户端开发完成前，后端必须确保 RPC 是好用的。

**测试命令：**

假设你已经登录并拿到了 `<JWT_TOKEN>`。

```bash
curl -X POST "http://localhost:7350/v2/rpc/claim_daily_reward" \
     -H "Authorization: Bearer <JWT_TOKEN>" \
     -H "Content-Type: application/json" \
     -d '"{\"dummy_param\": \"ignored\"}"'
```
*注意：RPC 的 Body 必须是 JSON 格式的字符串。如果 Go 端不读取 payload，传什么都可以，但必须是合法的 JSON。*

**预期结果 (第一次运行)：**
```json
{
  "payload": "{\"success\":true,\"message\":\"领取成功\",\"gold_received\":100,\"new_balance\":0}"
}
```

**预期结果 (立即运行第二次)：**
```json
{
  "payload": "{\"success\":false,\"message\":\"冷却时间未到，请稍后再试\",\"gold_received\":0,\"new_balance\":0}"
}
```

---

### 总结开发流程

1.  **定义需求**：确定输入（参数）和输出（返回值）。
2.  **服务端 (Go)**：
    *   编写函数 `func(..., payload string) (string, error)`。
    *   解析 Payload（反序列化 JSON）。
    *   执行逻辑（读写数据库/钱包）。
    *   返回结果（序列化 JSON）。
    *   在 `InitModule` 中 `RegisterRpc`。
3.  **客户端 (UE Blueprints)**：
    *   构建 JSON 字符串作为参数。
    *   调用 `Send RPC` 节点，填入对应的 Function ID。
    *   解析返回的 JSON 字符串更新 UI。