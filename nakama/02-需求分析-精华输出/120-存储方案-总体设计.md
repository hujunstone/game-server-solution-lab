## Nakama Demo 存储方案总体设计（CockroachDB + 内存缓存）

### 1. 目标与约束
- **目标**：在保证玩法正确性的前提下，兼顾读多写少的业务特性（势力、配置）、高频读写的玩家在线状态（战斗、跑商）、以及可扩展性和运维简单性。
- **基础设施**：  
  - 主持久化使用 **CockroachDB**（已设计 `player_character`、`caravan`、`trade_good`、`battle_*` 等表）。  
  - 后端为 **Nakama Go Runtime** 模块（RPC、实时战斗等）。  
  - 客户端为 UE 蓝图，通过 Nakama SDK 调用 RPC / Realtime。

### 2. 存储分层总体架构

- **应用内存层（Authoritative Runtime State）**  
  - 每个 Nakama 节点进程内维护：当前在线玩家会话、战斗状态、行军状态等 **短生命周期热数据**。  
  - 特点：超高读写频率、对延迟敏感、不直接暴露给客户端。

- **配置与静态数据层（Config / Reference Data）**  
  - 如势力 `faction`、出身 `background_archetype`、技能树 `skill_definition`、商品与节点配置 `trade_good` / `trade_node` 等（详细字段参见《003-数据结构设计》4.1 节）。  
  - 运行时 **启动或定期预加载到内存缓存**，避免频繁访问 DB。

- **业务持久化层（Persistent State in CockroachDB）**  
  - 玩家角色、属性、背包、商队、货物、战斗日志、价格快照等（对应《003-数据结构设计》4.2~4.4 表）。  
  - CockroachDB 负责 **持久化、一致性与查询**。

- **分布式缓存层（Redis 等 NoSQL，现阶段可选）**  
  - 当前 Demo 规模：**可以暂不引入 Redis**，依赖 CockroachDB + 进程内缓存即可。  
  - 当并发量提升或拆多服务时，可增加 Redis 作为 **跨进程共享缓存**（排行榜、热点配置、限流计数等）。  
  - 推荐监控指标与阈值：  
    - 单节点 CockroachDB 查询 QPS > 2k 且 95 线 > 40ms；  
    - 静态配置命中率 < 95% 或多节点间需要共享版本号；  
    - 在线并发 > 10k 且需要横向扩容多个 Nakama 进程处理同一个逻辑空间。

> 结论：**现阶段优先采用 “应用内存缓存 + CockroachDB 持久化” 双层架构，Redis 作为后续扩展选项，而非必需依赖。**

### 3. 各类数据的存储策略

#### 3.1 静态/低频变更数据（势力、技能、物品、地图）
- **来源**：`faction`、`background_archetype`、`skill_tree`、`skill_definition`、`item_template`、`trade_good`、`trade_node`、`trade_node_stock` 等。
- **特性**：读多写少、改动多在版本迭代或运营期批量修改。
- **设计**：
  - 权威源：**CockroachDB**（已有完整表结构，方便 GM 工具/SQL 统计与迁移管理）。  
  - 运行时：  
    - Nakama 模块在 `InitModule` 时一次性加载到内存（例如 `map[code]Config`）。  
    - 提供只读查询 API，逻辑层不要每次经由 DB。
  - 若后续需要 **Lua/前端直读配置**，可从 DB 导出静态 JSON 文件供客户端使用，但服务器仍以 DB 为准。

#### 3.2 玩家长生命周期数据（账号、角色、属性、背包、商队）
- **表**：`player_character`、`character_attribute`、`character_item`、`crew_member`、`caravan`、`caravan_cargo` 等。
- **读写模式**：
  - 登录 / 进入场景时：  
    - 从 CockroachDB 一次性读取对应角色的完整档案，构建内存对象（`CharacterSessionState`）。  
  - 在线过程：  
    - 业务逻辑 **只操作内存对象**（例如购买货物更新内存中的 `CaravanCargo` 列表）。  
  - 持久化：  
    - **关键节点**：角色创建、完成交易、战斗结束、货物变更、下线、重要任务完成 —— 立即写 DB（同步或放入可靠队列短延迟写）。  
    - **定期快照**：例如每 30–60 秒批量刷新“脏数据”（Dirty Flag）到 CockroachDB，降低单次高频写压力。

> 设计原则：**战斗/跑商逻辑绝不直接依赖实时 DB 查询**；DB 只作为状态快照与审计来源。

#### 3.3 高频易丢弃数据（战斗过程、行军实时状态）
- **表**：`battle_encounter`、`battle_action_log`、行军中间状态（可选单独表或仅在内存）。  
- **策略**：
  - 战斗回合内的行动、BUFF 刷新、HP 回落等，全部在 **内存中计算**。  
  - 每个回合或合适的间隔，将精简版日志写入 `battle_action_log`（用于审计和回放）。  
  - 战斗结束时，将战斗结果、掉落、伤病等写入 `battle_encounter.result_payload`，并同步更新角色/商队持久化数据。  
  - 行军过程（旅行进度、随机事件抽取）也只在内存中维护，**到达节点或遭遇战触发时** 再写 DB。

### 4. 是否需要 Redis / NoSQL

- **当前阶段（单模块 Demo，Nakama 为唯一后端）**：
  - CockroachDB 已提供分布式、高可用能力；  
  - 游戏内多数热数据可在每个 Nakama 节点内存中维护；  
  - 因此 **不强依赖 Redis**，可以不引入额外组件，简化部署。

- **后续扩展场景**（可考虑引入 Redis 等 NoSQL）：
  - 多服务拆分（排行榜、聊天、好友等独立服务）需要共享缓存。  
  - 大规模并发下：  
    - 配置的热 Key（如热门商品、热门节点）使用 Redis 缓存减少 DB 压力；  
    - 使用 Redis 做 **分布式锁 / 限流**（例如某节点限时抢购）。  
  - 实现 **跨节点的实时状态同步**（如世界 BOSS 血量、全服事件进度）。

> 综上，Redis 建议作为 **第二阶段可插拔优化选项**，初版架构不依赖它即可上线。一旦满足上述任意阈值，应评估接入 Redis，统一通过配置开关控制。

### 5. 接口与数据访问路径设计

#### 5.1 RPC / Realtime Handler 的读写路径
- Nakama Go Runtime 中，每个功能接口一般流程（支持多节点时需依赖 **Sticky Session** 或基于用户 ID 的一致性哈希，把同一角色固定在同一节点）： 
  1. 客户端调用 Nakama RPC / Realtime 消息。  
  2. Handler 从 **内存 Session / 本地缓存** 读取当前玩家/商队/战斗状态。  
  3. 业务逻辑在内存中完成运算（扣钱、加货、计算伤害等）。  
  4. 标记相关对象为 **脏数据（Dirty）**（即“内存态与 CockroachDB 快照已不一致，需要在随后某个时点落盘同步”），并决定：  
     - 立即持久化（关键事务，例如交易结算）；  
     - 或交给后台 Flush 任务在短时间窗口内批量更新。  
  5. 返回结果给客户端。

- **不推荐**：  
  - Handler 每次操作都直接 `SELECT/UPDATE` CockroachDB（高延迟 & 易产生竞态）。  
  - 客户端绕过 Nakama 直接访问 DB（安全性与一致性都会崩溃）。

#### 5.2 内存访问 vs 直接 DB 访问

- **直接读写 DB 的情况（服务端内部）**：
  - 启动加载静态配置。  
  - 定期后台任务（统计、排名、备份）。  
  - GM 工具、数据修复脚本。  

- **其余绝大多数在线逻辑**：  
  - 优先从内存结构读取与更新，**必要时才落盘**。若发生节点故障，可依赖 CockroachDB 最新快照 + Redis/消息总线广播的最后一条状态来重建 Session。

### 6. 持久化时机与策略

- **立即持久化（强一致、关键事务）**：
  - 角色创建 / 删除。  
  - 交易结算：购买/出售货物、资金变更。  
  - 战斗结算：经验、掉落、伤病、死亡。  
  - 商队货物大额变更、雇佣/解雇队员。  
  - 玩家下线（Session 关闭）前的最终 Flush。

- **定时/批量持久化（弱实时，提升性能）**：
  - 普通属性变化（小量 HP 回复、士气波动）。  
  - 行军过程中的中间状态（时间戳、位置等）。  
  - 做法示例：  
    - 每 30–60 秒由专用 `FlushWorker`（后台 Goroutine，带重试与超时机制）扫描在线 Session，找出有 Dirty 标记的对象，批量 `UPDATE`。  
    - 使用一个轻量队列（Channel）收集写请求，由后台 Worker 顺序写 DB，失败时退避重试并告警。

- **日志类持久化**：
  - 战斗日志、价格快照等体量大的数据，可异步写入。  
  - 可考虑使用 **批量 INSERT** 或 CockroachDB 的事务批处理 API。

### 7. 缓存方案设计

#### 7.1 进程内缓存（必选）

- **静态配置缓存**：
  - 在 `InitModule` 时加载所有 `faction`、`background_archetype`、`skill_definition`、`trade_node_stock` 等。  
  - 存入只读 `map[code]Config`，整个进程生命周期内不变；若需要热更新，可增加版本控制与定时重载。

- **玩家 Session 缓存**：
  - 每个在线玩家一个 `SessionState`：  
    - 基础角色信息（`player_character` + `character_attribute`）。  
    - 商队状态（`caravan` + `caravan_cargo`）。  
    - 当前战斗/行军状态（仅内存，无需映射到表）。  
  - 使用 `map[character_id]*SessionState` + 读写锁；Session 生命周期与 Nakama 会话绑定。

#### 7.2 分布式缓存（可选 Redis）

- 设计要点（如果后续引入）：  
  - 采用 **Cache-Aside + 版本号** 模式：  
    - 读：`GET cache (命中且 version == current_version) → 返回；否则 Query DB → Set cache(version)`；  
    - 写：`Update DB → Publish 失效消息（Redis Pub/Sub 或 Nakama 通知） → 其他节点删除旧缓存`。  
  - 适用对象：  
    - 某些热点静态配置（例如当前版本的活动配置）。  
    - 排行榜/统计（可单独设计 Sorted Set + 周期性持久化）。  
  - 缓存失效策略：TTL + 主动失效（版本号、消息总线等）；长生命周期数据以版本号为准，短生命周期数据以 TTL 为准。

> 引入 Redis 后需同步完善 **健康探针 + 断线降级策略**：若 Redis 不可用，所有逻辑自动退回 CockroachDB + 本地缓存，避免全局雪崩。

### 8. 监控、告警与容灾

- **指标采集**：  
  - CockroachDB：写延迟、失败率、事务冲突率。  
  - Nakama Runtime：RPC 时延、FlushWorker backlog、内存 Session 数。  
  - Cache：命中率、版本同步延迟。
- **告警阈值**（示例）：  
  - CockroachDB 写失败率 > 0.5% 连续 5 分钟告警；  
  - FlushWorker backlog > 1000 或等待时间 > 10s 告警；  
  - Redis/缓存节点失联 > 30 秒告警。
- **容灾策略**：  
  - Flush 失败：进入重试队列，超出重试次数将记录补偿任务，运维可手动触发。  
  - 节点宕机：其他节点依据 CockroachDB 快照重新加载 Session，并通过实时频道通知客户端重连。  
  - 配置热更：先写 DB + bump 版本号，再发布失效消息，确保所有节点一致。

### 9. 示例数据流

#### 9.1 一次典型交易流程
1. 客户端调用 `rpc_get_trade_quotes`：  
   - Handler 使用节点/商品配置的内存缓存 + 最近一次 `market_price_snapshot` 计算报价。  
2. 玩家确认购买，调用 `rpc_execute_trade`：  
   - Handler 从 SessionState 中读取资金、货物状态。  
   - 内存中计算扣款、增加 `CaravanCargo`。  
   - 立即写 CockroachDB：更新资金、`caravan_cargo`、`market_price_snapshot.quota_remaining`。  
   - 返回新状态给客户端。

#### 9.2 一次战斗流程
1. 遭遇战触发，创建内存中的 BattleState，并在 DB 中插入一条 `battle_encounter` 记录。  
2. 每回合客户端通过 `rpc_submit_turn` 上传行动，服务端在内存中模拟，按需写入 `battle_action_log`。  
3. 战斗结束时：  
   - 内存中结算经验、掉落、伤病；  
   - 一次性更新相关角色/商队数据到 CockroachDB；  
   - 更新 `battle_encounter.result_payload`。

### 10. 小结

- **CockroachDB**：唯一权威持久化层，负责长生命周期数据与日志；Schema 已覆盖角色、商队、贸易和战斗。  
- **Redis / NoSQL**：当前 Demo 阶段非必需，可在并发与功能扩展后作为共享缓存与分布式协调组件接入。  
- **接口访问模式**：客户端只与 Nakama RPC/Realtime 通信，服务端逻辑优先操作内存状态，对 DB 做按需、批量的持久化写入。  
- **缓存策略**：进程内缓存是标配（静态表 + SessionState），分布式缓存作为后续优化；战斗和行军等高频逻辑严格在内存中运行，避免 DB 成为性能瓶颈。


