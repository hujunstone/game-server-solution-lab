我先梳理一下整个项目中“用户相关接口是如何访问数据库”的脉络：  
1）先快速扫一眼项目结构，看看是后端语言/框架（Go/TS/Java 等）和 DB 类型；  
2）再用搜索找出 user 相关的 controller/router、service、repository/DAO、以及直接操作 DB 的部分；  
3）最后给你一个整体调用链：从 HTTP / RPC → handler → service → DB 的流程，并列出关键文件。

我现在去扫项目结构并搜索 user 相关代码。

[2 tools called]

已经找到了后端主要代码目录 `server`，接下来我会重点阅读 account/auth/friend 等 user 相关 API 文件，并顺着调用链查到具体的 DB 封装和表结构，然后给你整理一条清晰的“请求 → handler → service → DB”的流程说明和涉及文件列表。

[3 tools called]

已经定位到 `server` 目录里专门的 `api_user.go`、`core_user.go` 和 `core_account.go`/`core_authenticate.go` 等文件，这些是用户接口到核心逻辑的关键。我接下来会打开这些文件，梳理从 API 到 DB 的调用流程，并补上具体涉及的 DB 操作位置和表结构。

[5 tools called]

已经确认了核心的 user/account 相关核心逻辑和数据库表结构（`users`、`user_device`、`user_edge` 等），接下来我会再看一眼对应的 API 层文件（如 `api_account.go`/`api_authenticate.go`），然后用简洁的中文帮你总结“接口 → 核心逻辑 → SQL/表”的整体调用关系和涉及的关键文件列表。

[4 tools called]

### 总体模式（从接口到 DB）

**整体架构是：gRPC/HTTP API → `ApiServer` 的 `api_*.go` → `core_*.go` 里的核心函数 → 直接用 `database/sql` + 手写 SQL 操作 Postgres。**

通用流程（几乎所有 user 相关接口都类似）：

1. **API 层（`ApiServer`）**
    - 在 `server/api_*.go` 里实现，例如 `GetUsers`、`GetAccount`、`AuthenticateEmail`、`ListFriends` 等。
    - 做：
        - 从 `ctx` 里取当前用户 ID、用户名等。
        - 调用 “Before Hook”（`s.runtime.BeforeXXX()`），允许脚本扩展/拦截。
        - 参数校验（UUID 格式、用户名长度等）。
        - 调用对应的 **核心函数**（在 `core_*.go` 或 `core_user.go` 这类文件里）。
        - 调用 “After Hook”（`s.runtime.AfterXXX()`）。
    - API 层本身**一般不直接写 SQL**，而是把 `ctx` / `logger` / `s.db` 等传给核心函数。

2. **核心逻辑层（`core_*.go` / `core_user.go` 等）**
    - 在这些文件里**集中写 SQL**，使用 `*sql.DB` / `*sql.Tx` 和 `ExecContext` / `QueryContext` 来操作 Postgres。
    - 对应不同业务：账号读写、登录/注册、多端绑定、拉黑/好友关系、封号/解封、导出/导入账号等。
    - 复杂写操作使用封装好的事务函数 `ExecuteInTx` / `ExecuteInTxPgx` 保证多条语句原子性。

3. **数据库层**
    - 由 `migrate/sql/20180103142001_initial_schema.sql` 定义 schema。
    - 主要通过以下表实现用户相关数据：
        - `users`：主用户表
        - `user_device`：设备与用户 ID 绑定
        - `user_edge`：用户间的关系（好友/邀请/拉黑）
        - `notification`：用户通知
        - `storage`：用户存储（Key-Value，JSONB）
        - `wallet_ledger`：钱包流水
        - `user_tombstone`：删除用户的“墓碑”记录

---

### 关键 DB 表（与 user 强相关）

- **`users` 表**（定义在 `migrate/sql/20180103142001_initial_schema.sql`）
    - 字段包括：
        - `id` (UUID, PK)
        - `username`、`display_name`、`avatar_url`
        - 本地化相关：`lang_tag`、`location`、`timezone`
        - `metadata` (JSONB)、`wallet` (JSONB)
        - 登录标识：`email`、`password`、`facebook_id`、`google_id`、`gamecenter_id`、`steam_id`、`custom_id`
        - `edge_count`（好友/关系计数）
        - `create_time`、`update_time`、`verify_time`、`disable_time`（禁用时间，用于封号）
    - 多个 UNIQUE 约束保障账号唯一性（`users_username_key`、`users_email_key` 等），核心逻辑会根据这些约束来识别“账号已存在”、“并发插入”等情况。

- **`user_device` 表**
    - 设备 ID 与 `user_id` 映射。
    - 设备登录/创号、导入账号时使用。

- **`user_edge` 表**
    - 用户间关系边：`source_id`、`destination_id`、`state`（0=好友，1/2=邀请，3=拉黑）、`position`。
    - 好友列表、拉黑、导入 Facebook/Steam 好友时读写该表，并联动更新 `users.edge_count`。

- **其他：**
    - `notification`：发送好友加入游戏等通知。
    - `storage`：用户自定义存储。
    - `wallet_ledger`：钱包变动记录。
    - `user_tombstone`：删除用户后记录 `user_id`，用于审计/不可再注册等场景。

---

### 主要代码文件（按功能分类）

**1）用户基本信息 / 账号接口**

- **API 层**
    - `server/api_account.go`
        - `GetAccount`：获取当前登录用户的完整账号信息（`users` + `user_device`）。
        - `UpdateAccount`：修改用户名、头像、语言、地区、时区等。
        - `DeleteAccount`：删除当前账号，内部会级联删除关联数据。
- **核心逻辑层**
    - `server/core_account.go`
        - `GetAccount` / `GetAccounts`：`SELECT ... FROM users u LEFT JOIN user_device`。
        - `UpdateAccounts` / `updateAccounts`：`UPDATE users SET ...`，根据传入字段构建动态 SQL。
        - `DeleteAccount`：使用事务：
            - 调用 `DeleteUser`（在 `core_user.go`）删除 `users` 表记录；
            - 删除该用户相关的 leaderboard 记录、group、storage 等；
            - 可选写入 `user_tombstone`。
    - `server/core_user.go`
        - `GetUsers`：根据 `ids` / `usernames` / `facebook_ids` 从 `users` 表批量 `SELECT`。
        - `GetRandomUsers`：从 `users` 表随机读取若干用户。
        - `DeleteUser`：`DELETE FROM users WHERE id = $1`，依赖数据库外键实现级联删除。
        - `BanUsers` / `UnbanUsers`：`UPDATE users SET disable_time = now()/1970...` 实现封号/解封。
        - `UserExistsAndDoesNotBlock`：检查用户是否存在且未对另一用户设置拉黑（`user_edge` 筛选 state=3）。

**2）登录 / 注册 / 绑定第三方账号**

- **API 层**
    - `server/api_authenticate.go`
        - `AuthenticateApple`、`AuthenticateCustom`、`AuthenticateDevice`、`AuthenticateEmail`、`AuthenticateUsername`、`AuthenticateFacebook`、`AuthenticateGoogle`、`AuthenticateSteam` 等。
        - 共同职责：
            - 调用对应 `BeforeAuthenticateXXX` 和 `AfterAuthenticateXXX` hook。
            - 校验输入（用户名合法性、Email 格式、自定义 ID 长度等）。
            - 调用核心 `AuthenticateXXX` 函数获取或创建用户。
            - 生成会话 token / refresh token，写入 `sessionCache`。

- **核心逻辑层**
    - `server/core_authenticate.go`
        - **典型模式：**
            - 先 `SELECT ... FROM users WHERE <标识字段> = $1` 判断账号是否存在、是否被禁用（`disable_time`）。
            - 若存在且未禁用：比对密码（Email/Username 登录用 bcrypt）、或直接返回用户 ID/用户名。
            - 若不存在：
                - 如果 `create = false`：返回 NotFound。
                - 如果 `create = true`：`INSERT INTO users (...) VALUES (...)` 创建新用户，必要时再 `UPDATE users SET email=...` 等。
            - 捕获 `pgconn.PgError`：
                - UNIQUE 冲突（如 `users_username_key`、`users_email_key` 等）映射为业务错误，如 `AlreadyExists` 或 Internal。
        - **关键函数示例：**
            - `AuthenticateApple` / `AuthenticateGoogle` / `AuthenticateFacebook` / `AuthenticateSteam`：
                - 调用 social client 验证第三方 token。
                - 依据外部 ID（`apple_id` / `google_id` / `facebook_id` / `steam_id`）查询/创建 `users` 记录。
                - 可选导入头像、显示名、邮箱。
            - `AuthenticateEmail` / `AuthenticateUsername`：
                - 用 Email 或用户名查询出 `password`，用 bcrypt 校验。
                - 支持 Email 注册（`INSERT INTO users (email, password, ...)`）。
            - `AuthenticateCustom`：
                - 通过 `custom_id` 查询/创建账号。
            - `AuthenticateDevice`：
                - 先用 `user_device.id` 找到 `user_id`，再查用户。
                - 如果不存在且允许创建：事务中：
                    - 如果当前 `device_id` 未被绑定，则先插入 `users`，再插入 `user_device`。

        - 另外还有：
            - `importSteamFriends` / `importFacebookFriends`、`resetUserFriends`、`importFriendsByUUID`：在认证后导入好友关系，写 `user_edge`，更新 `users.edge_count` 并发送通知。

**3）查询用户 / 好友关系**

- **用户查询**
    - `server/api_user.go`
        - `GetUsers`：根据 ID、用户名、Facebook ID 列表查用户，交由 `GetUsers`（`core_user.go`）执行 SQL。
    - `server/core_user.go`
        - 见上，`GetUsers`、`GetRandomUsers` 等。

- **好友相关**
    - `server/api_friend.go`
        - `ListFriends`、`ListFriendsOfFriends`、`AddFriends`、`DeleteFriends`、`BlockFriends`、`ImportFacebookFriends`、`ImportSteamFriends` 等。
        - API 层负责参数校验（比如不能加自己为好友、ID/用户名有效性等），然后调用核心函数。
    - `server/core_friend.go` + 部分辅助函数在 `core_authenticate.go`
        - 使用 `user_edge` 表维护关系：
            - `state` 表示好友/邀请/拉黑。
            - 变更好友关系时会同时 `UPDATE users.edge_count`。
        - 导入好友使用事务 + 多条 SQL `INSERT` / `UPDATE` 保证一致性。

---

### “接口 → DB” 的典型调用链示例

- **获取当前账号（GetAccount）**
    - `server/api_account.go::GetAccount`
        - 从 `ctx` 取当前 `userID` → 调 `GetAccount(ctx, logger, s.db, s.statusRegistry, userID)`。
    - `server/core_account.go::GetAccount`
        - 执行 `SELECT ... FROM users u WHERE u.id = $1`，并用 `array(select ud.id from user_device ud where u.id = ud.user_id)` 连同设备列表一起查出。
        - 将行数据映射为 `api.Account` / `api.User`。

- **更新账号基础信息（UpdateAccount）**
    - `server/api_account.go::UpdateAccount`
        - 校验用户名长度等 → 构造 `accountUpdate` 结构 → 调 `UpdateAccounts(ctx, logger, s.db, updates)`.
    - `server/core_account.go::UpdateAccounts` / `updateAccounts`
        - 使用 `ExecuteInTxPgx` 开事务，循环每个 `accountUpdate`，根据非空字段动态拼 `UPDATE users SET ... WHERE id=$1 AND (...)`，必要时处理唯一约束错误。

- **邮箱登录/注册（AuthenticateEmail）**
    - `server/api_authenticate.go::AuthenticateEmail`
        - 校验 email 格式、密码长度等 → 调 `AuthenticateEmail(ctx, logger, s.db, email, password, username, create)`。
    - `server/core_authenticate.go::AuthenticateEmail`
        - `SELECT id, username, password, disable_time FROM users WHERE email=$1`：
            - 如果存在：
                - 检查 `disable_time` 是否被禁用；
                - 用 bcrypt 比对密码。
            - 如果不存在且 `create=true`：
                - 生成 `userID`，`INSERT INTO users (id, username, email, password, create_time, update_time) VALUES ...`。
            - 返回 `userID` 和用户名给 API 层，API 层再生成 token。

- **添加好友（AddFriends，仅概念层）**
    - `server/api_friend.go::AddFriends`
        - 校验不能添加自己、用户名不能为空，必要时通过 `fetchUserID`（在 `core_user.go`）将用户名转换为用户 ID。
        - 调用核心的 `AddFriends` 相关函数（在 `core_friend.go`）：
            - 在事务内：
                - 根据当前关系更新/插入 `user_edge`；
                - 同步更新对应用户 `users.edge_count`；
            - 结束后可能发送通知。

---

### 总结一句话

**这个工程中所有 user 相关接口，本质都是：API 层做 Hook + 校验，然后把 `ctx/logger/db` 传给 `core_*.go` 或 `core_user.go` / `core_account.go` / `core_authenticate.go` 里的核心函数，由这些核心函数用手写 SQL（`QueryContext`/`ExecContext`，配合事务封装）直接操作 Postgres 上的 `users`、`user_device`、`user_edge` 等表。**

如果你想，我可以帮你画一张更直观的调用关系图（例如按“登录/注册”、“资料修改”、“好友关系”三大块拆开）。