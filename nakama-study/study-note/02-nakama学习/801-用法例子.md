[1 tool called]

## 1. 程序文件结构（Go 模块示例）

参考仓库里的 `sample_go_module/sample.go`，我们做一个自己的 Go 模块，结构大致如下（放在 Nakama 的源码外面或同级目录都可以）：

```text
demo_faction_module/
  go.mod
  faction_module.go
```

- **`go.mod`**：声明依赖 `github.com/heroiclabs/nakama-common`，版本与你使用的 Nakama 对齐。
- **`faction_module.go`**：实现 `InitModule`，在里面 `RegisterRpc("demo_faction_get", rpcGetFaction)`。

> 说明：这是 **Go Runtime 模块**，不是改 Nakama 源码。编译成 `.so` 后放到 `runtime.path` 指定目录，Nakama 启动时会自动加载。

---

## 2. 定义对象与 RPC 代码（核心示例）

下面是一个完整的最小示例：实现 `demo_faction_get` RPC，根据 `code` 查询 `demo_faction` 表并返回一条记录。

```go
// faction_module.go
package main

import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/heroiclabs/nakama-common/runtime"
)

// 请求参数：客户端传 {"code":"JINGSHANG"}
type FactionQuery struct {
	Code string `json:"code"`
}

// 查询结果：返回给客户端的 JSON
type Faction struct {
	FactionID   int64  `json:"faction_id"`
	Code        string `json:"code"`
	Name        string `json:"name"`
	BadgeIcon   string `json:"badge_icon,omitempty"`
	Description string `json:"description,omitempty"`
}

// Nakama 启动时会调用这个函数来初始化 Go 模块。
func InitModule(ctx context.Context, logger runtime.Logger, db *sql.DB, nk runtime.NakamaModule, initializer runtime.Initializer) error {
	// 注册一个自定义 RPC：id = "demo_faction_get"
	if err := initializer.RegisterRpc("demo_faction_get", rpcGetFaction); err != nil {
		return err
	}
	logger.Info("demo_faction_get RPC registered")
	return nil
}

// 具体 RPC 处理逻辑。
// payload 是客户端传来的字符串（一般是 JSON 字符串）。
// 返回值 string 会原样作为 payload 返回给客户端（外面再包一层 rtapi.Envelope，由 Nakama 处理）。
func rpcGetFaction(ctx context.Context, logger runtime.Logger, db *sql.DB, nk runtime.NakamaModule, payload string) (string, error) {
	logger.Info("demo_faction_get called with payload: %s", payload)

	// 1. 解析请求 JSON
	var req FactionQuery
	if payload != "" {
		if err := json.Unmarshal([]byte(payload), &req); err != nil {
			return "", fmt.Errorf("invalid payload json: %w", err)
		}
	}
	if req.Code == "" {
		return "", errors.New("code is required")
	}

	// 2. 查询数据库 demo_faction 表
	const query = `
SELECT faction_id, code, name, badge_icon, description
FROM demo_faction
WHERE code = $1
`
	row := db.QueryRowContext(ctx, query, req.Code)

	var f Faction
	if err := row.Scan(&f.FactionID, &f.Code, &f.Name, &f.BadgeIcon, &f.Description); err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return "", fmt.Errorf("faction not found: %s", req.Code)
		}
		return "", fmt.Errorf("db query error: %w", err)
	}

	// 3. 序列化为 JSON 字符串返回（Nakama 会把这个 string 放到 Rpc 响应的 payload 字段）。
	out, err := json.Marshal(f)
	if err != nil {
		return "", fmt.Errorf("marshal response error: %w", err)
	}

	// 返回 JSON 字符串；外层 pb/JSON Envelope 由 Nakama 负责。
	return string(out), nil
}
```

**要点：**

- Go RPC 里只看见/处理 **JSON 字符串**（`payload string`），不用自己处理 pb。
- Nakama 在外层自动用 `rtapi.Envelope` 用 JSON 或 Protobuf 封装（取决于客户端 `format` 参数）。

---

## 3. 关于 JSON 和 PB 是如何生成的

这一点很关键，容易混淆，分两层来说：

### 3.1 你的 RPC 负责任的“业务数据层”

- 在 Go 模块里，`payload` 和返回值都是 **字符串**。
- **推荐做法**：用 `encoding/json` 把它当作 JSON 解析/生成：
    - 收到：`json.Unmarshal([]byte(payload), &reqStruct)`
    - 返回：`json.Marshal(respStruct)` 得到 `[]byte`，转成 `string` 返回。
- 这层 **只与 JSON 打交道**，不处理 Protobuf。

### 3.2 Nakama 负责的“传输层”

- WebSocket / gRPC / HTTP 在 Nakama 内部统一用 `rtapi.Envelope` / `api.Rpc` 等 **已定义好的 Protobuf 消息**。
- 对于你注册的 `demo_faction_get`：
    - **WebSocket JSON 模式**：客户端发送 `{"rpc": {"id": "demo_faction_get", "payload": "{...}"}}`，Nakama 反序列化成 `rtapi.Envelope`，从中取出 `payload` 字符串给你的 Go 函数。
    - **WebSocket Protobuf 模式**：客户端发送 Protobuf 编码的 `rtapi.Envelope`，里面依然有 `payload` 字符串字段，Nakama 解码后再把这个字符串给你的 Go 函数。
- 同理，Go 函数返回的 `string` 被放回 `payload` 字段，再由 Nakama 编成 JSON 或 Protobuf 发给客户端。

**结论：**

> 想“同时支持 pb 和 json”，在 Go 模块里 **只需要处理 JSON 字符串**；  
> pb/JSON 的封包/解包在外层由 Nakama 自动完成。

你不需要为 `demo_faction` 自己写 `.proto` 文件，也不需要自己调用 `proto.Marshal`，除非你想做非常自定义的二进制协议（一般没必要）。

---

## 4. 让 Nakama 框架加载并使用这个模块

1. **初始化 Go 模块工程**

   在 `demo_faction_module` 目录下建 `go.mod`（go 版本按需调整）：

   ```go
   module demo_faction_module

   go 1.21

   require github.com/heroiclabs/nakama-common v1.32.0 // 版本号示例，与你的 Nakama 对齐
   ```

2. **编译成插件**

   在该目录下执行（Windows/Linux/Mac 命令略有差异，这里以 Linux/Mac 为例；Windows 目前不支持 Go plugin）：

   ```bash
   go build -buildmode=plugin -o demo_faction.so faction_module.go
   ```

   得到 `demo_faction.so`。

3. **放到 Nakama 的 runtime 路径下**

   在 Nakama 的配置文件（例如 `config.yml`）中，确保有类似配置：

   ```yaml
   runtime:
     path: "./modules"
   ```

   然后把 `demo_faction.so` 放到 `modules` 目录下，例如：

   ```text
   nakama/
     config.yml
     modules/
       demo_faction.so
   ```

4. **启动 Nakama**

   启动日志中应该能看到类似：

   > demo_faction_get RPC registered

   说明模块已经加载成功。

---

## 5. 如何自测调用这个 RPC

### 5.1 HTTP 方式（最简单）

在配置了 `http_key` 的情况下，可以用 HTTP 直接测试（不需要玩家会话 token，适合调试后台 RPC）：

```bash
curl -X POST "http://127.0.0.1:7350/v2/rpc/demo_faction_get?http_key=defaultkey&unwrap=true" \
  -H "Content-Type: application/json" \
  -d '{"code":"JINGSHANG"}'
```

- `demo_faction_get`：就是你在 `RegisterRpc` 时注册的 ID。
- `payload` 就是 body 里的 JSON，Nakama 会作为字符串传给 `rpcGetFaction`。
- 成功时响应大致是：

```json
{
  "faction_id": 1,
  "code": "JINGSHANG",
  "name": "晋商",
  "badge_icon": "icons/jingshang.png",
  "description": "......"
}
```

（如果加了 `unwrap=true`，会直接返回上面的 JSON；否则会包在 `{"payload":"...json string..."}` 结构里。）

### 5.2 带玩家会话的 HTTP / WebSocket / 蓝图 SDK

- **玩家登录**：用客户端 SDK / curl 调用 Nakama 的认证接口（如 `/v2/account/authenticate/email`），拿到 `session.Token`。
- **HTTP RPC（带会话）**：

  ```bash
  curl -X POST "http://127.0.0.1:7350/v2/rpc/demo_faction_get?unwrap=true" \
    -H "Authorization: Bearer <SESSION_TOKEN>" \
    -H "Content-Type: application/json" \
    -d '{"code":"JINGSHANG"}'
  ```

- **WebSocket / 蓝图 SDK**

    - WebSocket URL：

        - JSON 模式：
          ```text
          ws://127.0.0.1:7350/ws?token=<SESSION_TOKEN>&format=json
          ```
        - Protobuf 模式：
          ```text
          ws://127.0.0.1:7350/ws?token=<SESSION_TOKEN>&format=protobuf
          ```

    - 在 Unreal 蓝图 SDK 里，直接调用它封装好的 **“RPC 调用” 节点**，传入：
        - ID: `"demo_faction_get"`
        - Payload: `{"code":"JINGSHANG"}`（SDK 会自动序列化为字符串）
    - 无论你用 JSON 还是 Protobuf WebSocket，Nakama 都会把 RPC 请求路由到 `rpcGetFaction`，你的 Go 代码完全相同。

---

如果你愿意，我可以再帮你扩展这个例子，比如加一个“列表所有势力”的 RPC，或者加上分页、错误码规范（比如统一返回 `{code:int, message:string, data:...}` 的结构）。