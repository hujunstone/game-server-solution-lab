### 总体回答

**按 `09-需求设计.md`，服务器需要负责所有“算数+判定+持久化”的部分**，Nakama 提供的是“通用后端骨架”（账号、存储、多房间、RPC 等）。  
下面按功能块列出：**要实现什么 + 如何基于 Nakama 做 + 哪些是 Nakama 内置可直接用的**。

---

### 一、角色创建与属性系统

- **需要实现的自定义功能**
  - 名字规则校验：长度、字符集、敏感词过滤、重名检测。
  - 出身背景选择：限定晋商 + 落榜秀才/镖局趟子手/牙行牙侩。
  - 初始属性分配：按出身给 `str/agi/vit/int`。
  - 初始 HP/DEF 计算：用文档内公式。
  - 初始装备绑定：四件白装 + 出身对应武器。
  - 势力与声望初始值。

- **基于 Nakama 的实现方案**
  - **Nakama 复用**：
    - 账号/登录：用现成的设备登录/邮箱/社交登录（不自己造）。
    - 存储：`nk.storage_write / nk.storage_read` 保存 `characters` 集合。
    - RPC：用 `nk.register_rpc("characters.create")` 暴露创建接口。
  - **需要自己开发的逻辑**：
    - 在 `characters.lua` 中：
      - 实现 `characters.create`：做所有校验 + 属性/装备初始化 + 写 Storage。
      - 实现 `characters.get`：从 Storage 读出角色数据。
    - 敏感词、重名：
      - 简版：在 RPC 中查 Storage / 自定义表；  
      - 复杂版：可调用外部服务（HTTP）做敏感词检测。

---

### 二、技能与数值公式

- **需要实现的自定义功能**
  - 商贾之道、防卫之术两条技能树：等级、冷却、被动/主动效果。
  - 各种公式：
    - 识货/议价/打探成功率与价格浮动；
    - 攻击/重劈/破甲/包扎/治疗/手术的伤害与治疗；
    - 各状态（破甲、击晕、流血）的持续回合与效果。
  - 技能升级规则（最大 10 级，消耗/条件）。

- **基于 Nakama 的实现方案**
  - **Nakama 复用**：
    - 存储：在 `characters` / `team` 里保存技能等级。
    - RPC：例如 `skills.upgrade` / `battle.resolve` 里调用这些公式。
  - **需要自己开发的逻辑**：
    - 在一个 `config.lua` 定义**所有技能配置表**（公式参数、冷却、状态效果）。
    - 在 `battle.lua` / `trade.lua` 中写**纯函数**来计算：
      - 价格浮动、打探成功率；
      - 战斗中的技能伤害、状态变更。

---

### 三、装备与团队系统

- **需要实现的自定义功能**
  - 装备位与品质：
    - 加成范围、随机/固定属性、描述等。
  - 初始装备 + 后续换装（如果 Demo 做）。
  - 商队团队：
    - 成员职业（护卫/账房/郎中/向导/脚夫/货匠）；
    - 品质系数；
    - 招募流程：对白、价格、扣银两、上限 5 人。

- **基于 Nakama 的实现方案**
  - **Nakama 复用**：
    - 存储：`team` 集合保存成员列表，`inventory` 保存银两。
    - RPC：`team.get`、`team.hire_member` 等。
  - **需要自己开发的逻辑**：
    - 在 `team.lua`：
      - 实现 `team.get`：返回当前团队成员与品质系数。
      - 实现 `team.hire_member`：按文档招募对白 → 检查银两 → 写入团队成员 → 扣银两。
    - 在 `goods/currency` 相关模块内实现银两增减。

---

### 四、战斗系统（单队 vs NPC）

- **需要实现的自定义功能**
  - 回合流程：速度判定 → 行动选择 → 状态结算。
  - 命中 / 伤害 / 特效概率的所有公式。
  - 阵型效果：鱼鳞阵/方圆阵/雁行阵对伤害/防御/敏捷的加成。
  - 团队 AI：特别是郎中自动治疗流程。
  - 敌人模板与敌方团伙组合（流民团伙、山匪小队、马贼突袭队）。

- **基于 Nakama 的实现方案**
  - **Nakama 复用**：
    - RPC 模式（推荐 Demo）：  
      - `battle.resolve`：一次 RPC 跑完整场战斗，返回战斗日志。
    - 存储：从 `characters` / `team` / `inventory` / `combat_config` 读取属性与模板。
  - **需要自己开发的逻辑**：
    - 在 `combat_config`（Storage 或 Lua 表）中定义敌人/团伙/阵型配置。
    - 在 `battle.lua`：
      - 读入玩家/队伍/敌人数据；
      - 按你文档写完整回合循环、行动 AI、状态结算；
      - 计算掉落/伤害（可直接修改存储中的 HP/道具数量，也可以战后统一结算）。

- **未来扩展（多人战役或协作）**
  - **可复用 Nakama 的** authoritative match 机制：
    - 写 `match_handler`，用 Nakama 的 tick 循环做战斗同步；
    - 这部分是 Nakama 的强项之一，但 Demo 阶段可以先不做。

---

### 五、跑商与价格系统（`09` 后半部分）

- **需要实现的自定义功能**
  - 商品配置：品类、基础价格、稀有度。
  - 城市状态：发展度 D、本地偏好 D_local。
  - 全局行情：GlobalFactor、recent_volume。
  - 价格公式与配额公式（SalePrice / PurchasePrice / AvailableQuota）。

- **基于 Nakama 的实现方案**
  - **Nakama 复用**：
    - 全局配置与状态：用 Storage 的“无 user_id 对象”存 `goods_config`、`city_state`、`goods_global`。
    - RPC：`trade.get_prices`、`trade.buy`、`trade.sell`。
  - **需要自己开发的逻辑**：
    - 在 `trade.lua`：
      - 封装所有价格计算公式（用你文档里的 H_D / GlobalFactor 等）。
      - 实现购买/出售流程：检查配额、计算价格、扣增货物并更新全局 volume/GlobalFactor。

---

### 六、世界 / 路线（与 09 中战役、跑商有关）

- **需要实现的自定义功能**
  - 路线图：太原–石岭关–雁门关–大同，以及距离/风险配置。
  - 玩家当前位置与行军状态（在节点 or 在路上）。
  - 风险判定：路段风险系数 → 随机遇敌/团伙类型。
  - 与战役/扫荡山寨联动：降低风险、时效控制。

- **基于 Nakama 的实现方案**
  - **Nakama 复用**：
    - 存储：`world.location`（玩家位置信息）、`world_config.routes`、`world_events.route_modifiers`。
    - RPC：`world.travel_start`、`world.travel_finish`、`world.get_location`。
  - **需要自己开发的逻辑**：
    - 时间与距离判定：根据 `start_time + duration` 判断是否“合法到达”。
    - 路上事件：在 `travel_finish` 或周期性检查时，根据风险系数决定是否进入战斗（调用 `battle.resolve`）。

---

### 七、哪些可以直接用 Nakama，不需要你重造

- **账号与会话**
  - 所有认证（设备、邮箱、社交）、JWT token 生成与验证 → **全部用 Nakama 内置**。
- **数据持久化**
  - CockroachDB/Postgres + Nakama Storage API → **不自己写底层 DB 层**。
- **服务端 RPC 框架**
  - `nk.register_rpc` + REST/gRPC + WebSocket → **不需要自建 HTTP/gRPC 服务**。
- **实时房间 / Match / Streams / Chat**
  - 目前你的 Demo 以单人 PVE 为主，可以先只用 RPC；  
  - 以后做多队战役/协作战斗时，再复用这些能力。
- **通知与内购**
  - Nakama Notification、已有 `iap` 模块 → 以后有需要可以挂在你自己的逻辑后面用。

---

### 八、简单总结

- **必须自己开发的**：  
  - 所有《09-需求设计》中带公式/规则/流程的业务逻辑（角色创建、属性计算、队伍与招募、战斗、跑商价格与配额、路线与风险）。  
  - 这些都在 Lua/TS/Go 运行时代码里实现为 RPC/match handler，调用 Nakama 的存储和实时能力。

- **可以复用 Nakama 的**：  
  - 用户体系、连接协议、RPC 框架、存储层、实时房间与通知、IAP 等通用后端基础设施。

如果你希望下一步更落地，我可以挑一块（例如“角色创建 + 初始团队 + 初次战斗”），给出一套“对应 schema 的 Lua RPC 骨架”列表，直接映射到这些集合与字段。