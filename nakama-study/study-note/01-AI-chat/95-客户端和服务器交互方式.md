
如果客户端使用Nakama Unreal SDK和服务器通讯，总体双方交互的消息是否都使用Json，网络协议是什么，协议是否可选，涉及到的Nakama源码在什么文件中


### 1. 总体双方交互的消息格式与协议

- **消息格式：JSON**
  - 使用 Nakama Unreal SDK 时，绝大部分交互（包括 RPC、存储读写、匹配消息、聊天）**默认且主要使用 JSON**。
  - 这是因为 Nakama 的 HTTP API (REST) 和 WebSocket API 主要是为 JSON 设计的。
  - *例外*：Nakama 的 WebSocket 协议支持传输二进制（Binary）消息（OpCode 2），SDK 也可以发送字节数组，但在业务层面通常还是为了方便起见包装 JSON。

- **网络协议：HTTP/1.1 + WebSocket**
  - **HTTP (REST)**：用于**短连接请求**，如：身份验证（Authenticate）、RPC 调用（无状态）、Storage 读写、好友添加等。
  - **WebSocket**：用于**长连接实时交互**，如：Match（对战/副本）数据同步、聊天消息、状态通知（Notification）、Presence 变化、Party 组队。

- **协议是否可选？**
  - **对于 Unreal SDK 用户：基本没得选**。官方 UE SDK 封装的就是 HTTP + WebSocket。
  - **对于服务器端**：Nakama 服务器同时也暴露了 **gRPC** 端口（默认 7349），如果你不用官方 UE SDK，而是自己用 C++ 集成 gRPC 客户端库，那你就可以用 gRPC + Protobuf。但这属于“高级/非标”用法，官方 UE 插件不走这条路。

---

### 2. 涉及到的 Nakama 源码文件位置

如果你想看 Nakama 服务器端是如何处理这些 HTTP/WebSocket 请求并将其转化为内部逻辑的，请关注以下路径（基于你提供的文件列表）：

#### A. API 定义与协议入口
Nakama 使用 OpenAPI (Swagger) 和 gRPC 定义文件来生成接口。

- `apigrpc/apigrpc.pb.go`: gRPC 接口定义的生成代码。Nakama 内部其实是先定义了 gRPC 接口。
- `server/api.go`: **核心 API 实现入口**。这里实现了 Nakama 暴露给客户端的所有主要功能（登录、存储、RPC 等）。
  - 例如 `AuthenticateDevice`, `RpcFunc`, `StorageWrite` 等方法都在这里。

#### B. HTTP / REST 网关（JSON 转 gRPC）
Nakama 使用 [grpc-gateway](https://github.com/grpc-ecosystem/grpc-gateway) 自动把 gRPC 映射为 HTTP/JSON 接口。

- 实际上 Nakama 启动时会挂载一个 gRPC-Gateway。
- 相关的处理逻辑分散在 `server/` 目录下的初始化代码中（如 `server/server.go` 或 `server/runtime.go`），它负责把 HTTP `:7350` 的 JSON 请求转给内部的 gRPC 方法。

#### C. WebSocket (实时长连接) 处理
这是处理实时数据（Match, Chat, Presence）的地方。

- **`server/socket.go`** (需确认具体文件名，通常在 `server` 包下): 负责处理 WebSocket 连接的升级、握手、以及消息分发。
- **`server/session_ws.go`** (或类似 `session` 相关文件): 处理单个 WebSocket 会话的主循环。
  - 它会解析客户端发来的 JSON 封包（比如 `MatchDataSend`），并调用对应的处理函数。
- **`server/pipeline.go`**: **核心消息管道**。
  - 无论是 WebSocket 发来的即时消息，还是 RUDP（如果有启用），都会进入 `Pipeline`。
  - 这里有一个巨大的 `ProcessRequest` 函数，根据消息类型（Match, Chat, RPC...）分发到不同的 Controller。

#### D. 业务逻辑（RPC / Match 等）
- `server/runtime_lua.go` / `server/runtime_go.go`: 负责加载和运行你写的 Lua/Go 扩展代码。
- 当客户端发 `RPC` 请求时，`server/api.go` 里的 `RpcFunc` 会调用 `Runtime` 来执行你在 `data/modules` 下写的 Lua 脚本。

---

### 总结

- **协议**：客户端 SDK ↔ 服务器 = **HTTP/1.1 + WebSocket**。
- **格式**：**JSON**。
- **源码对应**：
  - **REST/RPC 接口实现**：`server/api.go`。
  - **WebSocket/实时消息入口**：`server/session_ws.go` 和 `server/pipeline.go`。
  - **API 定义**：`apigrpc/` 目录。
  - **扩展执行**：`server/runtime_*.go`。