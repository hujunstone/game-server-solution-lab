我先看一下你的 `09-需求设计.md`，了解你具体的业务/玩法需求，然后结合 Nakama 的扩展方式，给你一个有针对性的“二次开发路线”和落地步骤。

[1 tool called]

我看到了你这份详细的角色/战斗/团队设计文档，现在再快速扫一下你现有的 Lua/Go 运行时代码（例如 `clientrpc.lua`、`iap.go`），看看你当前已经做了哪些扩展，然后给你一条**结合当前工程结构的二次开发路线**，尽量按“从0到能支撑这个玩法”的顺序来讲。

[2 tools called]

### 总体思路：先“切片”，再落到 Nakama 的扩展点

你现在这个文档，本质上已经把**数值 & 玩法规则**写得很清楚了，下一步就是：  
**把这些规则拆成几块后端职责 → 对应到 Nakama 的运行时代码（Lua/TS/Go）和存储结构 → 客户端通过 RPC / 存储 / 匹配来调用。**

下面按“怎么用这个工程二次开发”给你一条比较实际的路线（假设你优先用 Lua 运行时扩展）。

---

### 1. 先决定：哪些逻辑放在服务器，哪些在客户端

建议**所有影响数值的核心逻辑放在 Nakama 服务端**：

- **必须在服务器做的**：
  - 角色创建：背景→初始属性、初始装备。
  - 属性公式：HP、DEF、伤害、命中率、技能效果（重劈、破甲、治疗、包扎、手术等）。
  - 团队系统：队员属性、雇佣消耗、队伍上限。
  - 战斗结算：每回合行动顺序、技能选择结果、伤害计算、状态结算。
  - 经济系统：银两扣除、物品消耗（药、麻沸散）、掉落等。
- **可以在客户端做展示的**：
  - 血条动画、技能表现、战斗回放 UI。
  - 只要“结果”是服务器已经算好的，你在前端只负责还原过程即可。

---

### 2. 在 `data/modules` 里按玩法拆模块

参考现在的 `clientrpc.lua` 写法（`nk.register_rpc`），按设计文档拆几个 Lua 模块，例如：

- **`characters.lua`**：角色/职业相关  
  - `rpc_create_character`：创建角色（姓名 + 性别 + 出身 + 初始属性 & 装备）
  - `rpc_get_character`：拉取当前角色信息
  - `rpc_update_attributes`：升级、加点等（后续）

- **`team.lua`**：团队成员与职业分工  
  - `rpc_get_team`：当前商队成员列表
  - `rpc_hire_member`：在酒馆/驿站雇佣成员，按你文档里的对白 & 价格扣银两
  - `rpc_fire_member` / 调整阵型等（后续）

- **`battle.lua`**：回合制战斗系统  
  - `rpc_start_battle`：发起一次战斗（传入敌人类型组合：流民/山匪/马贼等）
  - `rpc_round_action`（如果做逐回合）或 `rpc_resolve_battle`（一次性算完整战斗）
  - 返回：战斗过程日志（回合顺序、每次攻击/技能、伤害、状态变化）+ 最终结果

- **`config.lua`（可选）**：把设计文档里的静态表格做成 Lua 配置表  
  - 出身基础属性表
  - 装备品质/加成范围
  - 阵型效果
  - 敌人属性表
  - 技能数值表

---

### 3. 用 Nakama 的存储来承载你的“玩法数据”

在 Lua 里用 `nk.storage_write` / `nk.storage_read` 保存玩家数据：

- **推荐结构示例（逻辑上即可，不必一模一样）**：

  - `collection = "characters"`, `key = "main"`  
    ```json
    {
      "name": "苏明远",
      "gender": "male",
      "faction": "晋商",
      "background": "落榜秀才",
      "level": 1,
      "stats": { "str": 8, "agi": 8, "vit": 9, "int": 15 },
      "equipment": {
        "head": "...",
        "body": "...",
        "legs": "...",
        "feet": "...",
        "weapon": "青竹手杖"
      },
      "skills": { ... }
    }
    ```

  - `collection = "team"`, `key = "members"`  
    保存护卫/账房/郎中/向导/脚夫/货匠的列表、品质系数、当前阵型等。

  - `collection = "inventory"`, `key = "currency"`  
    保存银两数量、药品数量等，用于雇佣成员和战斗消耗。

---

### 4. 把你的数值公式写进服务器 RPC 里

以战斗为例，在 `battle.lua` 里：

- **行动顺序公式**：  
  \[
  出手速度 = 敏捷 × 0.8 + 鞋子加成 + 随机(-2\sim+2)
  \]
  在 Lua 中实现排序，生成行动队列。

- **命中率**：  
  \[
  命中率 = 50\% + (攻方敏捷 - 守方敏捷) × 0.5\%
  \]
  下限 30%，上限 80%。

- **伤害**：  
  \[
  实际伤害 = \max(3, (40 + 力量 + 武器伤害) - 敌人DEF)
  \]

- **技能效果**（示例：重劈）：
  - 伤害：\((基础伤害40 + 力量) × (1.0 + 技能等级 × 0.1)\)
  - 击晕概率：`10% + 等级 × 2%`（先判命中，再判特效）

- **团队 AI**（郎中自动治疗）：
  - 在每回合循环中，对“郎中”角色做：
    - 判断队友 HP & 状态 → 决定用【治疗】【包扎】【手术】哪一个技能（根据冷却 & 品阶）。
    - 按你文档里的治疗公式结算效果。

这样做的关键点是：**客户端永远只看到结果日志，算法藏在服务端，未来数值调整也集中在一处改。**

---

### 5. 战斗形态选择：RPC 一次结算 vs 权威房间（Match）

根据你 demo 目标，可以两步走：

- **Demo 阶段（PVE 为主）**：
  - 直接用 **RPC 一次结算**：
    - 客户端调用 `rpc_resolve_battle`，传入敌人配置 + 玩家战术指令（例如“本局使用鱼鳞阵 + 集中火力”）。
    - 服务器完整跑完战斗流程，返回：
      - 胜负
      - 战斗过程数组（每回合的行动）
      - 奖励（经验、掉落）
  - 客户端用返回的过程“回放”战斗。

- **后续如果要做多人协作/对战**：
  - 把核心战斗逻辑迁移到 **Nakama 的 authoritative match handler**（Lua/Go/TS）。
  - 使用 `nk.match_create`（你现在 `clientrpc.lua` 已有示例）创建对战房间，按回合收集玩家指令，再广播每回合结果。

---

### 6. 客户端如何调用这些后端能力

以 Unity / JS 客户端为例（思路相同）：

- 登录后拿到 `session`（设备登录 / 账号登录）。
- 通过 SDK 调用 RPC，例如：

  - `client.RpcAsync("characters.create", payloadJson)` → 创建角色。
  - `client.RpcAsync("team.hire_member", payloadJson)` → 雇佣团队成员。
  - `client.RpcAsync("battle.resolve", payloadJson)` → 发起一场战斗。

- 把 RPC 的返回 JSON 直接映射到前端数据模型，用来：
  - 显示角色属性面板。
  - 显示团队列表。
  - 回放战斗过程。

---

### 7. 结合现有工程的落地顺序（建议）

按开发路径给你一个**可执行的 1–4 周路线**：

1. **起服务**：先把 Nakama 用 Docker / 二进制跑起来，能进 Console，客户端能成功调用示例 `clientrpc.rpc_get`。
2. **角色模块**：
   - 在 `data/modules` 新建 `characters.lua`，实现 `create/get`，把“出身+初始属性+初始装备”逻辑做进去。
3. **团队模块**：
   - 实现队伍存储、雇佣流程（使用你文档里的对白 & 价格 & 属性表）。
4. **基础战斗 Demo**：
   - 在 `battle.lua` 中，先实现“单回合 / 简化版战斗结算”（只普攻+重劈），跑通一场“主角+一个护卫 vs 一队山匪”。
5. **逐步增加复杂度**：
   - 加入阵型加成、战术指令、状态结算（流血/破甲/击晕），再补上郎中 AI、脚夫、货匠等职业效果。
6. **再考虑 IAP / 付费点**：
   - 若有内购，可基于现有 `iap` Go 模块，增加你自己的“购买道具/雇佣高级成员”等 RPC，内部先调用 IAP 校验再发货。

---

如果你愿意，我可以帮你**按照上面的模块划分，先写一版 `characters.lua` / `team.lua` / `battle.lua` 的骨架代码（只保留关键函数和调用点）**，你直接在此基础上往里填具体数值逻辑。